'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class VideoPlayerHelper
 * @package Helpers
 */

var VideoPlayerHelper = function () {
  function VideoPlayerHelper() {
    _classCallCheck(this, VideoPlayerHelper);
  }

  _createClass(VideoPlayerHelper, null, [{
    key: 'formatIsAllowed',


    /**
     * @param {String} format
     * @returns {boolean}
     */


    /**
     * @var {string}
     */


    /**
     * @var {string}
     */


    /**
     * @var {string}
     */


    /**
     * @var {string}
     */


    /**
     * @var {string}
     */
    value: function formatIsAllowed() {
      var format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      return fileName ? this.ALLOWED_FORMATS.includes(format) : this.ALLOWED_FORMATS;
    }

    /**
     * @var {array}
     */


    /**
     * @var {string}
     */


    /**
     * @var {string}
     */


    /**
     * @var {string}
     */


    /**
     * @var {string}
     */

  }]);

  return VideoPlayerHelper;
}();

VideoPlayerHelper.VIDEO_TAG = 'video';
VideoPlayerHelper.VIDEO_PLAYER_TYPE = 'object';
VideoPlayerHelper.ATTRIBUTE_CONTROLS = 'controls';
VideoPlayerHelper.ATTRIBUTE_MUTE = 'mute';
VideoPlayerHelper.ATTRIBUTE_AUTOPLAY = 'autoplay';
VideoPlayerHelper.ATTRIBUTE_LOOP = 'loop';
VideoPlayerHelper.ATTRIBUTE_PRELOAD = 'preload';
VideoPlayerHelper.ATTRIBUTE_WIDTH = 'width';
VideoPlayerHelper.ATTRIBUTE_HEIGHT = 'height';
VideoPlayerHelper.ALLOWED_FORMATS = ['ogg', 'theora', 'mp4', 'webm'];
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class VideoPlayerHTMLHelper
 * @package Helpers
 */

var VideoPlayerHTMLHelper = function VideoPlayerHTMLHelper() {
  _classCallCheck(this, VideoPlayerHTMLHelper);
};

VideoPlayerHTMLHelper.MAIN_CONTAINER_CLASS = 'vp';
VideoPlayerHTMLHelper.WRAPPER_CONTAINER_CLASS = 'vp__wrapper';
VideoPlayerHTMLHelper.VIDEO_CONTAINER_CLASS = 'vp__video-container';
VideoPlayerHTMLHelper.CONTROLS_CONTAINER_CLASS = 'vp__controls-container';
VideoPlayerHTMLHelper.PROGRESS_BAR_CONTAINER_CLASS = 'controls-container__progress-bar-container';
VideoPlayerHTMLHelper.PREGRESS_BAR_CLASS = 'controls-container__progress-bar';
VideoPlayerHTMLHelper.CONTROLS_CLASS = 'controls-container__controls';
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class ComponentsHelper
 * @package Helpers
 */

var ComponentsHelper = function ComponentsHelper() {
  _classCallCheck(this, ComponentsHelper);
};

ComponentsHelper.COMPONENTS_NAMES = {
  'PlayButton': 'play-button',
  'PauseButton': 'pause-button'
};
ComponentsHelper.COMPONENTS_CLASSES_NAMES = {
  catalog: {
    button: 'catalog__item'
  }
};
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * VideoPlayer - класс для работы с JavaScript плеером
 * @class VideoPlayer
 * @package Client
 */

var VideoPlayer = function () {
  _createClass(VideoPlayer, [{
    key: 'containerObject',


    /**
     * @returnss {DOMObject}
     */


    /**
     * @var {Object}
     */


    /**
     * @var {DOMObject}
     */


    /**
     * @var {string}
     */


    /**
     * @var {number}
     */


    /**
     * @var {Array}
     */
    get: function get() {
      return this._containerObject;
    }

    /**
     * @param {containerObject} containerObject 
     */


    /**
     * @var {ComponentsFabric}
     */


    /**
     * @var {number}
     */


    /**
     * @var {DOMObject}
     */


    /**
     * @var {number}
     */


    /**
     * @var {Array}
     */
    ,
    set: function set(containerObject) {
      this._containerObject = containerObject;
    }

    /**
     * @returnss {DOMObject}
     */

  }, {
    key: 'videoPlayer',
    get: function get() {
      return this._videoPlayer;
    }

    /**
     * @param {DOMObject} videoPlayer 
     */
    ,
    set: function set(videoPlayer) {
      this._videoPlayer = videoPlayer;
    }

    /**
     * @returnss {Integer}
     */

  }, {
    key: 'playerId',
    get: function get() {
      return this._playerId;
    }

    /**
     * @returnss {Object}
     */

  }, {
    key: 'options',
    get: function get() {
      return this._options;
    }

    /**
     * @param {Object} options 
     */
    ,
    set: function set() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this._options = options;
    }

    /**
     * @returnss {Object}
     */

  }, {
    key: 'components',
    get: function get() {
      return this._components;
    }

    /**
     * @param {Object} components 
     */
    ,
    set: function set(components) {
      this._components = components;
    }

    /**
     * VideoPlayer constructor
     * @param {DOMObject} containerObject - DOM object of component
     * @returnss {VideoPlayer} - DOM object of video player
     */

  }]);

  function VideoPlayer() {
    var containerObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    _classCallCheck(this, VideoPlayer);

    this.ALLOWED_ATTRIBUTES = ['autoplay', 'preload', 'width', 'height', 'loop'];
    this.DEFAULT_COMPONENTS = ['PlayButton', 'PauseButton', 'MuteButton', 'FullscreenButton', 'VolumeButton', 'TimelineProgressbar', 'SourcesCollection', 'Catalog'];
    this._maxIdLength = 999999;
    this._minIdLength = 111111;
    this._playerPrefix = 'vp-';

    this._playerId = this.generatePlayerId();
    this.containerObject = containerObject;
    this.options = options;

    this.initializePlayer(containerObject);

    return this;
  }

  /**
   * @returnss {string}
   */


  _createClass(VideoPlayer, [{
    key: 'generatePlayerId',
    value: function generatePlayerId() {
      return this._playerPrefix + Math.floor(this._minIdLength + Math.random() * (this._maxIdLength - this._minIdLength));
    }

    /**
     * @param {DOMObject} containerObject - DOM object of component
     */

  }, {
    key: 'initializePlayer',
    value: function initializePlayer(containerObject) {
      this.initializeContainerObject(containerObject);
      this.initializeComponents(this.DEFAULT_COMPONENTS, this.playerId);
      this.initializePlayerOptions(this.options);
      this.initializeComponentsEvents();
    }

    /**
     * VideoPlayer initialization method
     * @param {DOMObject} containerObject
     * @param {Object} options
     */

  }, {
    key: 'initializeContainerObject',
    value: function initializeContainerObject(containerObject) {
      var videoPlayer = containerObject.querySelector('video');

      try {
        if ((typeof videoPlayer === 'undefined' ? 'undefined' : _typeof(videoPlayer)) == 'object' && videoPlayer) {
          this.videoPlayer = videoPlayer;
        } else {
          throw new InvalidTypeException('Invalid type of video player object.');
        }
      } catch (exception) {
        console.error(exception.message);
      }
    }

    /**
     * @param {Array} componentsNamesArray 
     * @param {Integer} playerId 
     */

  }, {
    key: 'initializeComponents',
    value: function initializeComponents() {
      var _this = this;

      var componentsNamesArray = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var playerId = arguments[1];

      var componentsObject = {},
          componentsFabric = new ComponentsFabric();

      componentsNamesArray.forEach(function (componentName) {
        componentsObject[componentName.toLowerCase()] = componentsFabric.makeOne(componentName, _this.videoPlayer);
        componentsObject[componentName.toLowerCase()].id = playerId + '-' + ComponentsHelper.COMPONENTS_NAMES[componentName];
        componentsObject[componentName.toLowerCase()].videoPlayer = _this.videoPlayer;
      });

      this.components = componentsObject;
    }

    /**
     * @param {Object} options
     */

  }, {
    key: 'initializePlayerOptions',
    value: function initializePlayerOptions(options) {
      var _this2 = this;

      if (options.videoplayer) {
        var videoPlayerOptionsModel = new VideoPlayerModel().fromObject(options.videoplayer);

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = Object.entries(videoPlayerOptionsModel)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step$value = _slicedToArray(_step.value, 2),
                key = _step$value[0],
                value = _step$value[1];

            this.videoPlayer.setAttribute(key, value);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      /**
       * Models initialization
       */
      Object.keys(options.components).forEach(function (componentName) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = Object.entries(options.components[componentName])[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _step2$value = _slicedToArray(_step2.value, 2),
                key = _step2$value[0],
                value = _step2$value[1];

            _this2.components[componentName][key] = value;
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      });
    }

    /**
     * @returns {void}
     */

  }, {
    key: 'initializeComponentsEvents',
    value: function initializeComponentsEvents() {
      var _this3 = this;

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        var _loop = function _loop() {
          var componentName = _step3.value;

          _this3.components[componentName].events.forEach(function (event) {
            _this3.components[componentName].setEvent(event.eventTarget, event.eventName, event.eventCallback);
          });
        };

        for (var _iterator3 = Object.keys(this.components)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
  }]);

  return VideoPlayer;
}();
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Main component class
 * @class Component
 * @package Components
 */

var Component = function () {
  _createClass(Component, [{
    key: 'videoPlayer',


    /**
     * @returns {DOMObject}
     */


    /**
     * @var {String}
     */
    get: function get() {
      return this._videoPlayer;
    }

    /**
     * @param {DOMObject} videoPlayer 
     */


    /**
     * @var {EventModel}
     */


    /**
     * @var {DOMObject}
     */
    ,
    set: function set(videoPlayer) {
      this._videoPlayer = videoPlayer;
    }

    /**
     * @returns {String}
     */

  }, {
    key: 'id',
    get: function get() {
      return this._id;
    }

    /**
     * @param {String} id 
     */
    ,
    set: function set(id) {
      this._id = id;
    }

    /**
     * @returns {EventModel}
     */

  }, {
    key: 'event',
    get: function get() {
      return this._event;
    }

    /**
     * @param {EventModel} event
     */
    ,
    set: function set(event) {
      this._event = event;
    }

    /**
     * @param {DOMObject} videoPlayer 
     * @param {Integer} id 
     */

  }]);

  function Component(videoPlayer, id) {
    _classCallCheck(this, Component);

    this.videoPlayer = videoPlayer;
    this.id = id;
  }

  /**
   * @param {DOMObject|NodeList|String} eventTarget 
   * @param {String} eventName 
   * @param {Function} eventCallback 
   */


  _createClass(Component, [{
    key: 'setEvent',
    value: function setEvent(eventTarget, eventName, eventCallback) {
      if (typeof eventCallback === 'function') {

        if (typeof eventTarget == 'string') {
          this.setDynamicEvent(eventTarget, eventName, eventCallback);
        } else {
          this.setDefaultEvent(eventTarget, eventName, eventCallback);
        }
      } else {
        throw new InvalidTypeException('Invalid type of component event, expected "function" type.');
      }
    }

    /**
     * Применяется, когда eventTarget DOMObject|NodeList
     * @param {DOMObject|NodeList} eventTarget 
     * @param {String} eventName 
     * @param {Function} eventCallback 
     */

  }, {
    key: 'setDefaultEvent',
    value: function setDefaultEvent(eventTarget, eventName, eventCallback) {
      if (eventTarget) {
        eventTarget.addEventListener(eventName, eventCallback);
      }

      if (document.getElementById(this.id)) {
        document.getElementById(this.id).addEventListener(eventName, eventCallback);
      }
    }

    /**
     * Применяется, когда eventTarget название класса или id
     * @param {String} eventTarget 
     * @param {String} eventName 
     * @param {Function} eventCallback 
     */

  }, {
    key: 'setDynamicEvent',
    value: function setDynamicEvent(eventTarget, eventName, eventCallback) {
      if (eventTarget) {
        document.addEventListener(eventName, function (e) {
          if (e.target && (e.target.className === eventTarget || e.target.id === eventTarget)) {
            eventCallback(e);
          }
        });
      }
    }
  }]);

  return Component;
}();
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class PlayButton
 * @extends Component
 * @package Components
 */

var PlayButton = function (_Component) {
  _inherits(PlayButton, _Component);

  /**
   * @param {DOMObject} videoPlayer 
   */
  function PlayButton(videoPlayer) {
    _classCallCheck(this, PlayButton);

    var _this = _possibleConstructorReturn(this, (PlayButton.__proto__ || Object.getPrototypeOf(PlayButton)).call(this));

    _this.events = [new EventModel().fromObject({
      eventName: 'click',
      eventCallback: function eventCallback() {
        /**
         * In this code block you can use "this" for
         * DOMElement which you bind with event.
         */

        videoPlayer.play();
      }
    })];
    return _this;
  }

  return PlayButton;
}(Component);
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class PauseButton
 * @extends Component
 * @package Components
 */

var PauseButton = function (_Component) {
  _inherits(PauseButton, _Component);

  /**
   * @param {DOMObject} videoPlayer 
   */
  function PauseButton(videoPlayer) {
    _classCallCheck(this, PauseButton);

    var _this = _possibleConstructorReturn(this, (PauseButton.__proto__ || Object.getPrototypeOf(PauseButton)).call(this));

    _this.events = [new EventModel().fromObject({
      eventName: 'click',
      eventCallback: function eventCallback() {
        /**
         * In this code block you can use "this" for
         * DOMElement which you bind with event.
         */

        videoPlayer.pause();
      }
    })];
    return _this;
  }

  return PauseButton;
}(Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class MuteButton
 * @extends Component
 * @package Components
 */

var MuteButton = function (_Component) {
  _inherits(MuteButton, _Component);

  _createClass(MuteButton, [{
    key: 'muted',


    /**
     * @returns {Boolean}
     */
    get: function get() {
      return this._muted;
    }

    /**
     * @param {Boolean} muted
     */


    /**
     * @var {Boolean}
     */
    ,
    set: function set(muted) {
      this._muted = muted;
    }

    /**
     * @param {DOMObject} videoPlayer 
     */

  }]);

  function MuteButton(videoPlayer) {
    _classCallCheck(this, MuteButton);

    var _this = _possibleConstructorReturn(this, (MuteButton.__proto__ || Object.getPrototypeOf(MuteButton)).call(this));

    _this.events = [new EventModel().fromObject({
      eventName: 'click',
      eventCallback: function eventCallback() {
        /**
         * In this code block you can use "this" for
         * DOMElement which you bind with event.
         */

        videoPlayer.muted = !Boolean(videoPlayer.muted);
      }
    })];
    return _this;
  }

  return MuteButton;
}(Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class FullscreenButton
 * @extends Component
 * @package Components
 */

var FullscreenButton = function (_Component) {
  _inherits(FullscreenButton, _Component);

  _createClass(FullscreenButton, [{
    key: 'fullscreen',


    /**
     * @returns {Boolean}
     */
    get: function get() {
      return this._fullscreen;
    }

    /**
     * @param {Boolean}
     */


    /**
     * @var {Boolean}
     */
    ,
    set: function set(fullscreen) {
      this._fullscreen = Boolean(fullscreen);
    }

    /**
     * @param {DOMObject} videoPlayer 
     */

  }]);

  function FullscreenButton(videoPlayer) {
    _classCallCheck(this, FullscreenButton);

    var _this = _possibleConstructorReturn(this, (FullscreenButton.__proto__ || Object.getPrototypeOf(FullscreenButton)).call(this));

    var that = _this;

    _this.events = [new EventModel().fromObject({
      eventName: 'click',
      eventCallback: function eventCallback() {
        /**
         * In this code block you can use "this" for
         * DOMElement which you bind with event.
         */

        var isFullscreen = void 0,
            videoPlayerContainer = document.querySelector('.' + VideoPlayerHTMLHelper.MAIN_CONTAINER_CLASS);

        isFullscreen = this.getAttribute('data-fullscreen') == 'true' ? true : false;

        if (isFullscreen) {
          that.closeFullscreen(this, videoPlayerContainer);
        } else {
          that.openFullscreen(this, videoPlayerContainer);
        }

        this.setAttribute('data-fullscreen', that.fullscreen);
      }
    })];
    return _this;
  }

  /**
   * @param {DOMObject} fullscreenButtonElement 
   * @param {DOMObject} videoPlayerContainer 
   */


  _createClass(FullscreenButton, [{
    key: 'openFullscreen',
    value: function openFullscreen(fullscreenButtonElement, videoPlayerContainer) {
      var isFullscreen = false;

      if (videoPlayerContainer.requestFullscreen) {
        videoPlayerContainer.requestFullscreen();
        isFullscreen = true;
      }

      if (videoPlayerContainer.mozRequestFullScreen) {
        /* Firefox */
        videoPlayerContainer.mozRequestFullScreen();
        isFullscreen = true;
      }

      if (videoPlayerContainer.webkitRequestFullscreen) {
        /* Chrome, Safari and Opera */
        videoPlayerContainer.webkitRequestFullscreen();
        isFullscreen = true;
      }

      if (videoPlayerContainer.msRequestFullscreen) {
        /* IE/Edge */
        videoPlayerContainer.msRequestFullscreen();
        isFullscreen = true;
      }

      this.fullscreen = isFullscreen;
    }

    /**
     * @param {DOMObject} fullscreenButtonElement 
     * @param {DOMObject} videoPlayerContainer 
     */

  }, {
    key: 'closeFullscreen',
    value: function closeFullscreen(fullscreenButtonElement, videoPlayerContainer) {
      var isFullscreen = true;

      if (document.exitFullscreen) {
        document.exitFullscreen();
        isFullscreen = false;
      }

      if (document.mozCancelFullScreen) {
        /* Firefox */
        document.mozCancelFullScreen();
        isFullscreen = false;
      }

      if (document.webkitExitFullscreen) {
        /* Chrome, Safari and Opera */
        document.webkitExitFullscreen();
        isFullscreen = false;
      }

      if (document.msExitFullscreen) {
        /* IE/Edge */
        document.msExitFullscreen();
        isFullscreen = false;
      }

      this.fullscreen = isFullscreen;
    }
  }]);

  return FullscreenButton;
}(Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class VolumeButton
 * @extends Component
 * @package Components
 */

var VolumeButton = function (_Component) {
  _inherits(VolumeButton, _Component);

  _createClass(VolumeButton, [{
    key: 'step',


    /**
     * @returns {Number}
     */


    /**
     * @var {Number}
     */


    /**
     * @var {Integer}
     */
    get: function get() {
      return this._step;
    }

    /**
     * @param {Number}
     */


    /**
     * @var {Number}
     */


    /**
     * @var {Integer}
     */
    ,
    set: function set(step) {
      this._step = step;
    }

    /**
     * @returns {Number}
     */

  }, {
    key: 'volume',
    get: function get() {
      return this._volume;
    }

    /**
     * @param {Number} volume
     */
    ,
    set: function set(volume) {
      this._volume = volume;
      this.videoPlayer.volume = volume;
    }

    /**
     * @param {DOMObject} videoPlayer 
     */

  }]);

  function VolumeButton(videoPlayer) {
    _classCallCheck(this, VolumeButton);

    var _this = _possibleConstructorReturn(this, (VolumeButton.__proto__ || Object.getPrototypeOf(VolumeButton)).call(this));

    _this.MAX = 1;
    _this.MIN = 0;
    _this._step = 0.1;
    _this._volume = 1;


    var that = _this;

    _this.events = [new EventModel().fromObject({
      eventName: 'input',
      eventCallback: function eventCallback(e) {
        /**
         * In this code block you can use "this" for
         * DOMElement which you bind with event.
         */
        e.target.setAttribute('value', that.volume);
        that.volume = e.target.value;
      }
    }), new EventModel().fromObject({
      eventTarget: window,
      eventName: 'DOMContentLoaded',
      eventCallback: function eventCallback(e) {
        /**
         * In this code block you can use "this" for
         * DOMElement which you bind with event.
         */
        var volumeButton = document.getElementById(that.id);

        volumeButton.setAttribute('max', that.MAX);
        volumeButton.setAttribute('min', that.MIN);
        volumeButton.setAttribute('step', that.step);
        volumeButton.setAttribute('value', that.volume);
      }
    })];
    return _this;
  }

  return VolumeButton;
}(Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class TimelineProgressbar
 * @extends Component
 * @package Components
 */

var TimelineProgressbar = function (_Component) {
  _inherits(TimelineProgressbar, _Component);

  _createClass(TimelineProgressbar, [{
    key: 'currentTime',


    /**
     * @returns {Number}
     */


    /**
     * @var {Number}
     */


    /**
     * @var {Number}
     */


    /**
     * @var {Integer}
     */
    get: function get() {
      return this._currentTime;
    }

    /**
     * @param {Number} currentTime
     */


    /**
     * @var {Boolean}
     */


    /**
     * @var {Number}
     */


    /**
     * @var {Integer}
     */
    ,
    set: function set(currentTime) {
      this._currentTime = currentTime;
      this.videoPlayer.currentTime = currentTime;
    }

    /**
     * @returns {Number}
     */

  }, {
    key: 'step',
    get: function get() {
      return this._step;
    }

    /**
     * @param {Number}
     */
    ,
    set: function set(step) {
      this._step = step;
    }

    /**
     * @returns {Number}
     */

  }, {
    key: 'duration',
    get: function get() {
      return this._duration;
    }

    /**
     * @param {Number}
     */
    ,
    set: function set(duration) {
      this._duration = duration;
    }

    /**
     * @returns {Boolean}
     */

  }, {
    key: 'ended',
    get: function get() {
      return this.videoPlayer.ended;
    }

    /**
     * @param {DOMObject} videoPlayer 
     */

  }]);

  function TimelineProgressbar(videoPlayer) {
    _classCallCheck(this, TimelineProgressbar);

    var _this = _possibleConstructorReturn(this, (TimelineProgressbar.__proto__ || Object.getPrototypeOf(TimelineProgressbar)).call(this));

    _this.MAX = 100;
    _this.MIN = 0;
    _this._currentTime = 0;
    _this._step = 0.5;


    var that = _this;

    _this.duration = videoPlayer.duration;
    _this.events = [new EventModel().fromObject({
      eventName: 'input',
      eventCallback: function eventCallback(e) {
        /**
         * In this code block you can use "this" for
         * DOMElement which you bind with event.
         */
        e.target.setAttribute('value', that.currentTime);
        that.currentTime = e.target.value;
      }
    }), new EventModel().fromObject({
      eventTarget: videoPlayer,
      eventName: 'timeupdate',
      eventCallback: function eventCallback(e) {
        /**
         * In this code block you can use "this" for
         * DOMElement which you bind with event.
         */
        var timeLineElement = document.getElementById(that.id);

        timeLineElement.value = e.target.currentTime;
      }
    }), new EventModel().fromObject({
      eventTarget: videoPlayer,
      eventName: 'loadedmetadata',
      eventCallback: function eventCallback(e) {
        /**
         * In this code block you can use "this" for
         * DOMElement which you bind with event.
         */
        var timeLineElement = document.getElementById(that.id);
        that.duration = this.duration;

        timeLineElement.setAttribute('max', that.duration.toFixed(0));
        timeLineElement.setAttribute('min', that.MIN);
        timeLineElement.setAttribute('step', that.step);
        timeLineElement.setAttribute('value', that.currentTime);
      }
    })];
    return _this;
  }

  return TimelineProgressbar;
}(Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SourcesCollection
 * @extends Component
 * @package Components
 */

var SourcesCollection = function (_Component) {
  _inherits(SourcesCollection, _Component);

  _createClass(SourcesCollection, [{
    key: 'collection',


    /**
     * @returns SourcesCollectionModel
     */
    get: function get() {
      return this._collection;
    }

    /**
     * @param SourcesCollectionModel collection
     */


    /**
     * @var SourcesCollectionModel
     */
    ,
    set: function set(collection) {
      this._collection = new SourcesCollectionModel(collection).collection;
    }

    /**
     * @param {DOMObject} videoPlayer
     */

  }]);

  function SourcesCollection(videoPlayer) {
    _classCallCheck(this, SourcesCollection);

    var _this = _possibleConstructorReturn(this, (SourcesCollection.__proto__ || Object.getPrototypeOf(SourcesCollection)).call(this));

    _this.events = [new EventModel().fromObject({
      eventName: 'click',
      eventCallback: function eventCallback() {
        /**
         * In this code block you can use "this" for
         * DOMElement which you bind with event.
         */
      }
    })];
    return _this;
  }

  return SourcesCollection;
}(Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class Catalog
 * @extends Component
 * @package Components
 */

var Catalog = function (_Component) {
  _inherits(Catalog, _Component);

  _createClass(Catalog, [{
    key: 'collection',


    /**
     * @returns Array<CatalogModel>
     */


    /**
     * @var Array<CatalogModel>
     */
    get: function get() {
      return this._collection;
    }

    /**
     * @param Array<CatalogModel> collection
     */


    /**
     * @var CatalogCollectionModel
     */
    ,
    set: function set(collection) {
      this._collection = new CatalogCollectionModel(collection).collection;
      this._collectionModel = new CatalogCollectionModel(collection);
    }

    /**
     * @returns CatalogCollectionModel
     */

  }, {
    key: 'collectionModel',
    get: function get() {
      return this._collectionModel;
    }

    /**
     * @param DOMObject videoPlayer 
     */

  }]);

  function Catalog(videoPlayer) {
    _classCallCheck(this, Catalog);

    var _this = _possibleConstructorReturn(this, (Catalog.__proto__ || Object.getPrototypeOf(Catalog)).call(this));

    var that = _this;

    _this.events = [new EventModel().fromObject({
      eventName: 'click',
      eventTarget: ComponentsHelper.COMPONENTS_CLASSES_NAMES.catalog.button,
      eventCallback: function eventCallback(e) {
        /**
         * In this code block you can use "this" for
         * DOMElement which you bind with event.
         */

        var currentItemSlug = e.target.dataset.slug,
            catalogModel = void 0;

        if (currentItemSlug) {
          /**
          * removing old source nodes
          */
          videoPlayer.querySelectorAll('source').forEach(function (source) {
            videoPlayer.removeChild(source);
          });

          /**
           * paste new source nodes
           */
          catalogModel = that.collectionModel.getBy('slug', currentItemSlug);
          catalogModel.video.map(function (linkModel) {
            /**
             * create and append node
             */
            videoPlayer.appendChild(that.createSource(linkModel));
          });

          videoPlayer.load();
        }
      }
    })];
    return _this;
  }

  /**
   * @param LinkModel linkModel 
   * @return DOMElement
   */


  _createClass(Catalog, [{
    key: 'createSource',
    value: function createSource(linkModel) {
      var sourceElement = document.createElement('source');
      sourceElement.setAttribute('src', linkModel.link);
      sourceElement.setAttribute('format', linkModel.format);

      return sourceElement;
    }
  }]);

  return Catalog;
}(Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class ComponentsFabric
 * @package Components
 */

var ComponentsFabric = function () {
  function ComponentsFabric() {
    _classCallCheck(this, ComponentsFabric);
  }

  _createClass(ComponentsFabric, [{
    key: 'makeOne',


    /**
     * @param {String} componentName
     * @param {DOMObject} videoPlayer
     * @returns {Component}
     * @throws UndefinedComponentException
     */
    value: function makeOne(componentName, videoPlayer) {

      var component;

      switch (componentName) {
        case 'PlayButton':
          component = new PlayButton(videoPlayer);
          break;
        case 'PauseButton':
          component = new PauseButton(videoPlayer);
          break;
        case 'MuteButton':
          component = new MuteButton(videoPlayer);
          break;
        case 'FullscreenButton':
          component = new FullscreenButton(videoPlayer);
          break;
        case 'VolumeButton':
          component = new VolumeButton(videoPlayer);
          break;
        case 'TimelineProgressbar':
          component = new TimelineProgressbar(videoPlayer);
          break;
        case 'SourcesCollection':
          component = new SourcesCollection(videoPlayer);
          break;
        case 'Catalog':
          component = new Catalog(videoPlayer);
          break;
        default:
          throw new UndefinedComponentException(componentName + ' is not found.');
          break;
      }

      return component;
    }

    /**
     * @param {Array} componentsNamesArray 
     * @param {DOMObject} videoPlayer
     * @returns {Array}
     */

  }, {
    key: 'make',
    value: function make(componentsNamesArray, videoPlayer) {
      var _this = this;

      var componentsArray = [];

      componentsNamesArray.forEach(function (componentName) {
        componentsArray.push(_this.makeOne(componentName, videoPlayer));
      });

      return componentsArray;
    }
  }]);

  return ComponentsFabric;
}();
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class Decorator
 * @package Components/Decorators
 */

var Decorator = function () {
  function Decorator() {
    _classCallCheck(this, Decorator);
  }

  _createClass(Decorator, [{
    key: "fromObject",


    /**
     * @param {Object} object 
     * @returns {Decorator}
     */
    value: function fromObject() {
      var object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (object.className) this.className = object.className;

      return this;
    }
  }, {
    key: "className",
    get: function get() {
      return this._className;
    }

    /**
     * @var {String}
     */
    ,
    set: function set(className) {
      this._className = className;
    }
  }]);

  return Decorator;
}();
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class ButtonDecorator
 * @extends Decorator
 * @package Components/Decorators/BaseDecorators
 */

var ButtonDecorator = function (_Decorator) {
  _inherits(ButtonDecorator, _Decorator);

  function ButtonDecorator() {
    _classCallCheck(this, ButtonDecorator);

    return _possibleConstructorReturn(this, (ButtonDecorator.__proto__ || Object.getPrototypeOf(ButtonDecorator)).apply(this, arguments));
  }

  _createClass(ButtonDecorator, [{
    key: "fromObject",


    /**
     * @param {Object} object 
     * @returns {Decorator}
     */
    value: function fromObject() {
      var object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (object.borderType) this._borderType = object.borderType;

      if (object.borderColor) this._borderColor = object.borderColor;

      if (object.borderWidth) this._borderWidth = object.borderWidth;

      if (object.borderRadius) this._borderRadius = object.borderRadius;

      if (object.width) this._width = object.width;

      if (object.height) this._height = object.height;

      if (object.backgroundColor) this._backgroundColor = object.backgroundColor;

      if (object.color) this._color = object.color;

      if (object.fontSize) this._fontSize = object.fontSize;

      if (object.fontWeight) this._fontWeight = object.fontWeight;

      return this;
    }
  }, {
    key: "borderType",


    /**
     * @returns {String}
     */


    /**
     * @var {String}
     */


    /**
     * @var {String}
     */


    /**
     * @var {String}
     */


    /**
     * @var {String}
     */


    /**
     * @var {String}
     */
    get: function get() {
      return this._borderType;
    }

    /**
     * @param {String} borderType 
     */


    /**
     * @var {String}
     */


    /**
     * @var {String}
     */


    /**
     * @var {String}
     */


    /**
     * @var {String}
     */


    /**
     * @var {String}
     */
    ,
    set: function set(borderType) {
      this._borderType = borderType;
    }

    /**
     * @returns {String}
     */

  }, {
    key: "borderColor",
    get: function get() {
      return this._borderColor;
    }

    /**
     * @param {String} borderColor 
     */
    ,
    set: function set(borderColor) {
      this._borderColor = borderColor;
    }

    /**
     * @returns {String}
     */

  }, {
    key: "borderWidth",
    get: function get() {
      return this._borderWidth;
    }

    /**
     * @param {String} borderWidth 
     */
    ,
    set: function set(borderWidth) {
      this._borderWidth = borderWidth;
    }

    /**
     * @returns {String}
     */

  }, {
    key: "borderRadius",
    get: function get() {
      return this._borderRadius;
    }

    /**
     * @param {String} borderRadius 
     */
    ,
    set: function set(borderRadius) {
      this._borderRadius = borderRadius;
    }

    /**
     * @returns {String}
     */

  }, {
    key: "width",
    get: function get() {
      return this._width;
    }

    /**
     * @param {String} width 
     */
    ,
    set: function set(width) {
      this._width = width;
    }

    /**
     * @returns {String}
     */

  }, {
    key: "height",
    get: function get() {
      return this._height;
    }

    /**
     * @param {String} height 
     */
    ,
    set: function set(height) {
      this._height = height;
    }

    /**
     * @returns {String}
     */

  }, {
    key: "backgroundColor",
    get: function get() {
      return this._backgroundColor;
    }

    /**
     * @param {String} backgroundColor 
     */
    ,
    set: function set(backgroundColor) {
      this._backgroundColor = backgroundColor;
    }

    /**
     * @returns {String}
     */

  }, {
    key: "color",
    get: function get() {
      return this.color;
    }

    /**
     * @param {String} color 
     */
    ,
    set: function set(color) {
      this._color = color;
    }

    /**
     * @returns {String}
     */

  }, {
    key: "fontSize",
    get: function get() {
      return this._fontSize;
    }

    /**
     * @param {String} fontSize 
     */
    ,
    set: function set(fontSize) {
      this._fontSize = fontSize;
    }

    /**
     * @returns {String}
     */

  }, {
    key: "fontWeight",
    get: function get() {
      return this._fontWeight;
    }

    /**
     * @param {String} fontWeight 
     */
    ,
    set: function set(fontWeight) {
      this._fontWeight = fontWeight;
    }
  }]);

  return ButtonDecorator;
}(Decorator);
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class ProgressbarDecorator
 * @package Components/Decorators
 */

/**
 * @see https://html5css.ru/edithtm/index.php
 */

var ProgressbarDecorator = function ProgressbarDecorator() {
  _classCallCheck(this, ProgressbarDecorator);
};
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class PlayButtonDecorator
 * @extends ButtonDecorator
 * @package Components/Decorators
 */

var PlayButtonDecorator = function (_ButtonDecorator) {
  _inherits(PlayButtonDecorator, _ButtonDecorator);

  function PlayButtonDecorator() {
    _classCallCheck(this, PlayButtonDecorator);

    return _possibleConstructorReturn(this, (PlayButtonDecorator.__proto__ || Object.getPrototypeOf(PlayButtonDecorator)).apply(this, arguments));
  }

  return PlayButtonDecorator;
}(ButtonDecorator);
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class PauseButtonDecorator
 * @extends ButtonDecorator
 * @package Components/Decorators
 */

var PauseButtonDecorator = function (_ButtonDecorator) {
  _inherits(PauseButtonDecorator, _ButtonDecorator);

  function PauseButtonDecorator() {
    _classCallCheck(this, PauseButtonDecorator);

    return _possibleConstructorReturn(this, (PauseButtonDecorator.__proto__ || Object.getPrototypeOf(PauseButtonDecorator)).apply(this, arguments));
  }

  return PauseButtonDecorator;
}(ButtonDecorator);
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class MuteButtonDecorator
 * @extends ButtonDecorator
 * @package Components/Decorators
 */

var MuteButtonDecorator = function (_ButtonDecorator) {
  _inherits(MuteButtonDecorator, _ButtonDecorator);

  function MuteButtonDecorator() {
    _classCallCheck(this, MuteButtonDecorator);

    return _possibleConstructorReturn(this, (MuteButtonDecorator.__proto__ || Object.getPrototypeOf(MuteButtonDecorator)).apply(this, arguments));
  }

  return MuteButtonDecorator;
}(ButtonDecorator);
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class FullscreenButtonDecorator
 * @extends ButtonDecorator
 * @package Components/Decorators
 */

var FullscreenButtonDecorator = function (_ButtonDecorator) {
  _inherits(FullscreenButtonDecorator, _ButtonDecorator);

  function FullscreenButtonDecorator() {
    _classCallCheck(this, FullscreenButtonDecorator);

    return _possibleConstructorReturn(this, (FullscreenButtonDecorator.__proto__ || Object.getPrototypeOf(FullscreenButtonDecorator)).apply(this, arguments));
  }

  return FullscreenButtonDecorator;
}(ButtonDecorator);
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class BaseModel
 * @package Models
 */

var BaseModel = function () {
  function BaseModel() {
    _classCallCheck(this, BaseModel);
  }

  _createClass(BaseModel, [{
    key: "fromObject",


    /**
     * @param {Object} optionsObject 
     * @returns {BaseModel}
     */
    value: function fromObject() {
      var optionsObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};


      if (optionsObject.id) this.id = String(optionsObject.id);

      return this;
    }
  }, {
    key: "id",


    /**
     * @returns {String}
     */
    get: function get() {
      return this._id;
    }

    /**
     * @param {String} id 
     */


    /**
     * @var {String}
     */
    ,
    set: function set(id) {
      this._id = id;
    }
  }]);

  return BaseModel;
}();
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class VideoPlayerModel
 * @extends BaseModel
 * @package Models
 */

var VideoPlayerModel = function (_BaseModel) {
  _inherits(VideoPlayerModel, _BaseModel);

  function VideoPlayerModel() {
    _classCallCheck(this, VideoPlayerModel);

    return _possibleConstructorReturn(this, (VideoPlayerModel.__proto__ || Object.getPrototypeOf(VideoPlayerModel)).apply(this, arguments));
  }

  _createClass(VideoPlayerModel, [{
    key: "fromObject",


    /**
     * @param {Object} optionsObject 
     * @returns {VideoPlayerModel}
     */
    value: function fromObject() {
      var optionsObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};


      var model = {};

      if (optionsObject.autoplay) model.autoplay = Boolean(optionsObject.autoplay);
      /** @link https://developers.google.com/web/updates/2017/09/autoplay-policy-changes */
      model.muted = Boolean(optionsObject.autoplay);

      if (optionsObject.preload) model.preload = Boolean(optionsObject.preload);

      if (optionsObject.width) model.width = String(optionsObject.width);

      if (optionsObject.height) model.width = String(optionsObject.height);

      if (optionsObject.loop) model.loop = Boolean(optionsObject.loop);

      return model;
    }
  }, {
    key: "autoplay",


    /**
     * @returns {Boolean}
     */


    /**
     * @var {String}
     */


    /**
     * @var {Boolean}
     */
    get: function get() {
      return this._autoplay;
    }

    /**
     * @param {Boolean} autoplay 
     */


    /**
     * @var {Boolean}
     */


    /**
     * @var {String}
     */


    /**
     * @var {Boolean}
     */
    ,
    set: function set(autoplay) {
      this._autoplay = autoplay;
    }

    /**
     * @returns {Boolean}
     */

  }, {
    key: "preload",
    get: function get() {
      return this._preload;
    }

    /**
     * @param {Boolean} preload 
     */
    ,
    set: function set(preload) {
      this._preload = preload;
    }

    /**
     * @returns {String}
     */

  }, {
    key: "width",
    get: function get() {
      return this._width;
    }

    /**
     * @param {String} width 
     */
    ,
    set: function set(width) {
      this._width = width;
    }

    /**
     * @returns {String}
     */

  }, {
    key: "height",
    get: function get() {
      return this._height;
    }

    /**
     * @param {String} height 
     */
    ,
    set: function set(height) {
      this._height = height;
    }

    /**
     * @returns {Boolean}
     */

  }, {
    key: "loop",
    get: function get() {
      return this._loop;
    }

    /**
     * @param {Boolean} loop 
     */
    ,
    set: function set(loop) {
      this._loop = loop;
    }
  }]);

  return VideoPlayerModel;
}(BaseModel);
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class PlayButtonModel
 * @extends BaseModel
 * @package Models
 */

var PlayButtonModel = function (_BaseModel) {
  _inherits(PlayButtonModel, _BaseModel);

  function PlayButtonModel() {
    _classCallCheck(this, PlayButtonModel);

    return _possibleConstructorReturn(this, (PlayButtonModel.__proto__ || Object.getPrototypeOf(PlayButtonModel)).apply(this, arguments));
  }

  return PlayButtonModel;
}(BaseModel);
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class PauseButtonModel
 * @extends BaseModel
 * @package Models
 */

var PauseButtonModel = function (_BaseModel) {
  _inherits(PauseButtonModel, _BaseModel);

  function PauseButtonModel() {
    _classCallCheck(this, PauseButtonModel);

    return _possibleConstructorReturn(this, (PauseButtonModel.__proto__ || Object.getPrototypeOf(PauseButtonModel)).apply(this, arguments));
  }

  return PauseButtonModel;
}(BaseModel);
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class MuteButtonModel
 * @extends BaseModel
 * @package Models
 */

var MuteButtonModel = function (_BaseModel) {
  _inherits(MuteButtonModel, _BaseModel);

  function MuteButtonModel() {
    _classCallCheck(this, MuteButtonModel);

    return _possibleConstructorReturn(this, (MuteButtonModel.__proto__ || Object.getPrototypeOf(MuteButtonModel)).apply(this, arguments));
  }

  return MuteButtonModel;
}(BaseModel);
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class FullscreenButtonModel
 * @extends BaseModel
 * @package Models
 */

var FullscreenButtonModel = function (_BaseModel) {
  _inherits(FullscreenButtonModel, _BaseModel);

  function FullscreenButtonModel() {
    _classCallCheck(this, FullscreenButtonModel);

    return _possibleConstructorReturn(this, (FullscreenButtonModel.__proto__ || Object.getPrototypeOf(FullscreenButtonModel)).apply(this, arguments));
  }

  return FullscreenButtonModel;
}(BaseModel);
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class VolumeButtonModel
 * @extends BaseModel
 * @package Models
 */

var VolumeButtonModel = function (_BaseModel) {
  _inherits(VolumeButtonModel, _BaseModel);

  function VolumeButtonModel() {
    _classCallCheck(this, VolumeButtonModel);

    return _possibleConstructorReturn(this, (VolumeButtonModel.__proto__ || Object.getPrototypeOf(VolumeButtonModel)).apply(this, arguments));
  }

  return VolumeButtonModel;
}(BaseModel);
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class TimelineProgressbarModel
 * @extends BaseModel
 * @package Models
 */

var TimelineProgressbarModel = function (_BaseModel) {
  _inherits(TimelineProgressbarModel, _BaseModel);

  function TimelineProgressbarModel() {
    _classCallCheck(this, TimelineProgressbarModel);

    return _possibleConstructorReturn(this, (TimelineProgressbarModel.__proto__ || Object.getPrototypeOf(TimelineProgressbarModel)).apply(this, arguments));
  }

  return TimelineProgressbarModel;
}(BaseModel);
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SourceModel
 * @extends BaseModel
 * @package Models
 */

var SourceModel = function (_BaseModel) {
  _inherits(SourceModel, _BaseModel);

  function SourceModel() {
    _classCallCheck(this, SourceModel);

    return _possibleConstructorReturn(this, (SourceModel.__proto__ || Object.getPrototypeOf(SourceModel)).apply(this, arguments));
  }

  _createClass(SourceModel, [{
    key: "fromObject",


    /**
     * @param {Object} optionsObject 
     * @returns {SourceModel}
     */
    value: function fromObject() {
      var optionsObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};


      if (optionsObject.name) this.name = String(optionsObject.name);

      if (optionsObject.link) this.link = String(optionsObject.link);

      if (optionsObject.mode) this.mode = String(optionsObject.mode);

      if (String(optionsObject.index)) this.index = parseInt(optionsObject.index);

      return this;
    }
  }, {
    key: "name",


    /**
     * @returns {String}
     */


    /**
     * @var {String}
     */


    /**
     * @var {String}
     */
    get: function get() {
      return this._name;
    }

    /**
     * @param {String} name
     */


    /**
     * @var {Integer}
     */


    /**
     * @var {String}
     */
    ,
    set: function set(name) {
      this._name = name;
    }

    /**
     * @returns {String}
     */

  }, {
    key: "link",
    get: function get() {
      return this._link;
    }

    /**
     * @param {String} link
     */
    ,
    set: function set(link) {
      this._link = link;
    }

    /**
     * @returns {String}
     */

  }, {
    key: "mode",
    get: function get() {
      return this._mode;
    }

    /**
     * @param {String} mode
     */
    ,
    set: function set(mode) {
      this._mode = mode;
    }

    /**
     * @returns {Integer}
     */

  }, {
    key: "index",
    get: function get() {
      return this._index;
    }

    /**
     * @param {Integer} index
     */
    ,
    set: function set(index) {
      this._index = index;
    }
  }]);

  return SourceModel;
}(BaseModel);
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class LinkModel
 * @package Models/CatalogModels
 */

var LinkModel = function () {
  function LinkModel() {
    _classCallCheck(this, LinkModel);
  }

  _createClass(LinkModel, [{
    key: "fromObject",


    /**
     * @param {Object} object 
     * @return LinkModel
     */
    value: function fromObject() {
      var object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (object.link) this.link = object.link;

      if (object.format) this.format = object.format;

      return this;
    }
  }, {
    key: "link",


    /**
     * @returns String
     */


    /**
     * @var String
     */
    get: function get() {
      return this._link;
    }

    /**
     * @param String
     */


    /**
     * @var String
     */
    ,
    set: function set(link) {
      this._link = link;
    }

    /**
     * @returns String
     */

  }, {
    key: "format",
    get: function get() {
      return this._format;
    }

    /**
     * @param String
     */
    ,
    set: function set(format) {
      this._format = format;
    }
  }]);

  return LinkModel;
}();
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class LinksCollectionModel
 * @package Models/CatalogModels
 */

var LinksCollectionModel = function () {
  _createClass(LinksCollectionModel, [{
    key: "collection",


    /**
     * @return Array<LinkModel>
     */
    get: function get() {
      return this._collection;
    }

    /**
     * @param Array
     */
    ,
    set: function set(collection) {
      this._collection = this.buildFromArray(collection);
    }
  }]);

  function LinksCollectionModel(array) {
    _classCallCheck(this, LinksCollectionModel);

    this.collection = array;
  }

  /**
   * @param {Array} array 
   * @return Array<LinkModel>
   */


  _createClass(LinksCollectionModel, [{
    key: "buildFromArray",
    value: function buildFromArray() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      var res = [];

      array.forEach(function (catalogObject) {
        res.push(new LinkModel().fromObject(catalogObject));
      });

      return res;
    }
  }]);

  return LinksCollectionModel;
}();
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class CatalogModel
 * @package Models
 */

var CatalogModel = function (_BaseModel) {
  _inherits(CatalogModel, _BaseModel);

  function CatalogModel() {
    _classCallCheck(this, CatalogModel);

    return _possibleConstructorReturn(this, (CatalogModel.__proto__ || Object.getPrototypeOf(CatalogModel)).apply(this, arguments));
  }

  _createClass(CatalogModel, [{
    key: "fromObject",
    value: function fromObject() {
      var object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (object.title) this.title = object.title;

      if (object.subTitle) this.subTitle = object.subTitle;

      if (object.slug) this.slug = object.slug;

      if (object.video) this.video = object.video;

      return this;
    }
  }, {
    key: "title",


    /**
     * @returns String
     */


    /**
     * @var String
     */


    /**
     * @var String
     */
    get: function get() {
      return this._title;
    }

    /**
     * @param String
     */


    /**
     * @var CatalogCollectionModel
     */


    /**
     * @var String
     */
    ,
    set: function set(title) {
      this._title = title;
    }

    /**
     * @returns String
     */

  }, {
    key: "subTitle",
    get: function get() {
      return this._subTitle;
    }

    /**
     * @param String
     */
    ,
    set: function set(subTitle) {
      this._subTitle = subTitle;
    }

    /**
     * @returns String
     */

  }, {
    key: "slug",
    get: function get() {
      return this._slug;
    }

    /**
     * @param String slug
     */
    ,
    set: function set(slug) {
      this._slug = slug;
    }

    /**
     * @returns Array<CatalogModel>
     */

  }, {
    key: "video",
    get: function get() {
      return this._video;
    }

    /**
     * @param CatalogCollectionModel
     */
    ,
    set: function set(video) {
      this._video = new LinksCollectionModel(video).collection;
    }
  }]);

  return CatalogModel;
}(BaseModel);
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class CatalogCollectionModel
 * @package Models
 */

var CatalogCollectionModel = function (_BaseModel) {
  _inherits(CatalogCollectionModel, _BaseModel);

  _createClass(CatalogCollectionModel, [{
    key: "collection",


    /**
     * @returns Array<CatalogModel>
     */
    get: function get() {
      return this._collection;
    }

    /**
     * @param Array<Object>
     */


    /**
     * @var Array<CatalogModel>
     */
    ,
    set: function set(collection) {
      this._collection = this.buildFromArray(collection);
    }
  }]);

  function CatalogCollectionModel(array) {
    _classCallCheck(this, CatalogCollectionModel);

    var _this = _possibleConstructorReturn(this, (CatalogCollectionModel.__proto__ || Object.getPrototypeOf(CatalogCollectionModel)).call(this));

    _this.collection = array;
    return _this;
  }

  /**
   * @param Array<Object>
   * @return Array<CatalogModel>
   */


  _createClass(CatalogCollectionModel, [{
    key: "buildFromArray",
    value: function buildFromArray() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      var res = [];

      array.forEach(function (catalogObject) {
        res.push(new CatalogModel().fromObject(catalogObject));
      });

      return res;
    }

    /**
     * @param String property
     * @param String value
     * @return CatalogModel|Boolean
     */

  }, {
    key: "getBy",
    value: function getBy(property, value) {
      var result = false;

      this.collection.map(function (item) {
        if (item[property] == value) {
          result = item;
        }
      });

      return result;
    }
  }]);

  return CatalogCollectionModel;
}(BaseModel);
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SourcesCollectionModel
 * @package Models
 */

var SourcesCollectionModel = function (_BaseModel) {
  _inherits(SourcesCollectionModel, _BaseModel);

  _createClass(SourcesCollectionModel, [{
    key: "collection",


    /**
     * @returns Array<SourceModel>
     */
    get: function get() {
      return this._collection;
    }

    /**
     * @param Array<Object>
     */


    /**
     * @var Array<SourceModel>
     */
    ,
    set: function set(collection) {
      this._collection = this.buildFromArray(collection);
    }
  }]);

  function SourcesCollectionModel(array) {
    _classCallCheck(this, SourcesCollectionModel);

    var _this = _possibleConstructorReturn(this, (SourcesCollectionModel.__proto__ || Object.getPrototypeOf(SourcesCollectionModel)).call(this));

    _this.collection = array;
    return _this;
  }

  /**
   * @param Array<Object>
   * @return Array<SourceModel>
   */


  _createClass(SourcesCollectionModel, [{
    key: "buildFromArray",
    value: function buildFromArray() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      var res = [];

      array.forEach(function (sourceObject) {
        res.push(new SourceModel().fromObject(sourceObject));
      });

      return res;
    }
  }]);

  return SourcesCollectionModel;
}(BaseModel);
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class EventModel
 * @package Models
 */

var EventModel = function () {
  function EventModel() {
    _classCallCheck(this, EventModel);
  }

  _createClass(EventModel, [{
    key: "fromObject",


    /**
     * @param {Object} object 
     * @returns {EventModel}
     */
    value: function fromObject() {
      var object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (object.eventName) this.eventName = object.eventName;

      if (object.eventTarget) this.eventTarget = object.eventTarget;

      if (object.eventCallback) this.eventCallback = object.eventCallback;

      return this;
    }
  }, {
    key: "eventName",


    /**
     * @returns {String}
     */


    /**
     * @var {DOMObject}
     */
    get: function get() {
      return this._eventName;
    }

    /**
     * @param {String} eventName 
     */


    /**
     * @var {Function}
     */


    /**
     * @var {String}
     */
    ,
    set: function set(eventName) {
      this._eventName = eventName;
    }

    /**
     * @var {DOMObject}
     */

  }, {
    key: "eventTarget",
    get: function get() {
      return this._eventTarget;
    }

    /**
     * @param {DOMObject} eventTarget 
     */
    ,
    set: function set(eventTarget) {
      this._eventTarget = eventTarget;
    }

    /**
     * @var {Function}
     */

  }, {
    key: "eventCallback",
    get: function get() {
      return this._eventCallback;
    }

    /**
     * @param {Function} eventCallback 
     */
    ,
    set: function set(eventCallback) {
      this._eventCallback = eventCallback;
    }
  }]);

  return EventModel;
}();
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class ModelsFabric
 * @package Models
 */

var ModelsFabric = function () {
  function ModelsFabric() {
    _classCallCheck(this, ModelsFabric);

    this.NAMES_ASSOCIATIONS = {
      'VideoPlayer': 'VideoPlayerModel',
      'PlayButton': 'PlayButtonModel',
      'PauseButton': 'PauseButtonModel',
      'MuteButton': 'MuteButtonModel',
      'FullscreenButton': 'FullscreenButtonModel',
      'VolumeButton': 'VolumeButtonModel',
      'TimelineProgressbar': 'TimelineProgressbarModel',
      'SourcesCollection': 'SourcesCollectionModel',
      'Catalog': 'CatalogCollectionModel'
    };
  }

  _createClass(ModelsFabric, [{
    key: 'makeOne',


    /**
     * @param {String} name - componentName/componentModel
     * @returns {Object}
     * @throws UndefinedComponentException
     */
    value: function makeOne(name) {
      var component = void 0;

      switch (this.findModelName(name).modelName) {
        case 'VideoPlayerModel':
          component = new VideoPlayerModel();
          break;
        case 'PlayButtonModel':
          component = new PlayButtonModel();
          break;
        case 'PauseButtonModel':
          component = new PauseButtonModel();
          break;
        case 'MuteButtonModel':
          component = new MuteButtonModel();
          break;
        case 'FullscreenButtonModel':
          component = new FullscreenButtonModel();
          break;
        case 'VolumeButtonModel':
          component = new VolumeButtonModel();
          break;
        case 'TimelineProgressbarModel':
          component = new TimelineProgressbarModel();
          break;
        case 'SourcesCollectionModel':
          component = new SourcesCollectionModel();
          break;
        case 'CatalogCollectionModel':
          component = new CatalogCollectionModel();
          break;
        default:
          throw new UndefinedComponentException(name + ' is not found.');
          break;
      }

      return component;
    }

    /**
     * @param {Array} componentsNamesArray
     * @returns {Array}
     */

  }, {
    key: 'make',
    value: function make(componentsNamesArray) {
      var _this = this;

      var componentsArray = [];

      componentsNamesArray.forEach(function (componentName) {
        componentsArray.push(_this.makeOne(componentName));
      });

      return componentsArray;
    }

    /**
     * @param {String} name 
     * @returns {String}
     */

  }, {
    key: 'findModelName',
    value: function findModelName(name) {
      if (this.isModelName(name)) {
        return this.getModelInfoByModelName(name);
      } else {
        return this.getModelInfoByComponentName(name);
      }
    }

    /**
     * @param {String} name
     * @returns {Boolean} 
     */

  }, {
    key: 'isModelName',
    value: function isModelName(name) {
      return (/(model)/.test(name.toLowerCase())
      );
    }

    /**
     * @param {String} name 
     * @returns {Object|Boolean}
     */

  }, {
    key: 'getModelInfoByModelName',
    value: function getModelInfoByModelName(name) {
      var _this2 = this;

      var result = false;

      Object.keys(this.NAMES_ASSOCIATIONS).forEach(function (componentName, index) {
        if (_this2.NAMES_ASSOCIATIONS[componentName].toLowerCase() === name.toLowerCase()) {
          result = {
            modelName: _this2.NAMES_ASSOCIATIONS[componentName],
            componentName: componentName,
            index: index
          };
        }
      });

      return result;
    }

    /**
     * Method return associated model name with component name
     * @param {String} name - componentName/componentModel
     * @returns {String|Object}
     */

  }, {
    key: 'getModelInfoByComponentName',
    value: function getModelInfoByComponentName(name) {
      var _this3 = this;

      var result = false;

      Object.keys(this.NAMES_ASSOCIATIONS).forEach(function (componentName, index) {
        if (componentName.toLowerCase() === name.toLowerCase()) {
          result = {
            modelName: _this3.NAMES_ASSOCIATIONS[componentName],
            componentName: name,
            index: index
          };
        }
      });

      return result;
    }
  }]);

  return ModelsFabric;
}();
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class VPException
 * @package Exceptions
 */

var VPException = function () {
  _createClass(VPException, [{
    key: 'message',


    /**
     * @returns {String}
     */


    /**
     * @var {string}
     */
    get: function get() {
      return this._message;
    }

    /**
     * @param {String} message
     */


    /**
     * @var {String}
     */
    ,
    set: function set(message) {
      this._message = message;
    }

    /**
     * @returns {String}
     */

  }, {
    key: 'name',
    get: function get() {
      return this._name;
    }

    /**
     * @param {String} name
     */
    ,
    set: function set(name) {
      this._name = name;
    }

    /**
     * VPException constructor
     * @param {String} message 
     */

  }]);

  function VPException() {
    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    _classCallCheck(this, VPException);

    this._name = 'VPException';

    this.name = name ? name : this.name;
    this.stack = Error.captureStackTrace(this, this.constructor);
    this.message = 'VideoPlayer Exception, ' + this.name + ': ' + message;

    return this;
  }

  return VPException;
}();
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class InvalidTypeException
 * @extends VPException
 * @package Exceptions
 */

var InvalidTypeException = function (_VPException) {
  _inherits(InvalidTypeException, _VPException);

  function InvalidTypeException() {
    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

    var _ret;

    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    _classCallCheck(this, InvalidTypeException);

    var _this = _possibleConstructorReturn(this, (InvalidTypeException.__proto__ || Object.getPrototypeOf(InvalidTypeException)).call(this, message, InvalidTypeException.name));

    _this._name = 'InvalidTypeException';

    _this.message = 'VideoPlayer Exception, ' + _this.name + ': ' + message;

    return _ret = _this, _possibleConstructorReturn(_this, _ret);
  }

  /**
   * @var {String}
   */


  return InvalidTypeException;
}(VPException);
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class InvalidTypeException
 * @extends VPException
 * @package Exceptions
 */

var UndefinedComponentException = function (_VPException) {
  _inherits(UndefinedComponentException, _VPException);

  function UndefinedComponentException() {
    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

    var _ret;

    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    _classCallCheck(this, UndefinedComponentException);

    var _this = _possibleConstructorReturn(this, (UndefinedComponentException.__proto__ || Object.getPrototypeOf(UndefinedComponentException)).call(this, message, InvalidTypeException.name));

    _this._name = 'UndefinedComponentException';

    _this.message = 'VideoPlayer Exception, ' + _this.name + ': ' + message;

    return _ret = _this, _possibleConstructorReturn(_this, _ret);
  }

  /**
   * @var {String}
   */


  return UndefinedComponentException;
}(VPException);